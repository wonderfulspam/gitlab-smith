# BEFORE: Scenario 2 - Complex Include Consolidation
# This shows a monolithic config that should be broken into includes

stages:
  - security
  - build
  - test
  - quality
  - deploy

variables:
  NODE_VERSION: "18"
  PYTHON_VERSION: "3.10"
  SECURITY_SCAN_IMAGE: "registry.company.com/security-scanner:latest"

# Security scanning jobs (should be in separate include)
security:sast:
  stage: security
  image: $SECURITY_SCAN_IMAGE
  script:
    - echo "Running SAST scan..."
    - sast-scanner --input . --output sast-results.json
    - echo "SAST scan completed"
  artifacts:
    reports:
      sast: sast-results.json
    paths:
      - sast-results.json
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

security:dependency:
  stage: security
  image: $SECURITY_SCAN_IMAGE
  script:
    - echo "Running dependency vulnerability scan..."
    - dependency-scanner --package-file package.json --output dependency-results.json
    - dependency-scanner --package-file requirements.txt --output python-dependency-results.json
    - echo "Dependency scan completed"
  artifacts:
    reports:
      dependency_scanning: dependency-results.json
    paths:
      - dependency-results.json
      - python-dependency-results.json
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

security:container:
  stage: security
  image: $SECURITY_SCAN_IMAGE
  services:
    - docker:20.10.16-dind
  script:
    - echo "Running container security scan..."
    - container-scanner --image app:$CI_COMMIT_SHA --output container-results.json
    - echo "Container scan completed"
  artifacts:
    reports:
      container_scanning: container-results.json
    paths:
      - container-results.json
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

# Frontend build jobs (should be in separate include)
build:frontend:js:
  stage: build
  image: node:$NODE_VERSION
  before_script:
    - npm cache clean --force
    - npm ci --cache .npm --prefer-offline
  script:
    - echo "Building frontend JavaScript"
    - npm run build:frontend:js
    - npm run minify:js
  artifacts:
    paths:
      - dist/js/
  cache:
    key: "frontend-js-$CI_COMMIT_REF_SLUG"
    paths:
      - node_modules/
      - .npm/

build:frontend:css:
  stage: build
  image: node:$NODE_VERSION
  before_script:
    - npm cache clean --force
    - npm ci --cache .npm --prefer-offline
  script:
    - echo "Building frontend CSS"
    - npm run build:frontend:css
    - npm run minify:css
  artifacts:
    paths:
      - dist/css/
  cache:
    key: "frontend-css-$CI_COMMIT_REF_SLUG"
    paths:
      - node_modules/
      - .npm/

build:frontend:assets:
  stage: build
  image: node:$NODE_VERSION
  before_script:
    - npm cache clean --force
    - npm ci --cache .npm --prefer-offline
  script:
    - echo "Processing frontend assets"
    - npm run build:assets
    - npm run optimize:images
  artifacts:
    paths:
      - dist/assets/
  cache:
    key: "frontend-assets-$CI_COMMIT_REF_SLUG"
    paths:
      - node_modules/
      - .npm/

# Backend build jobs (should be in separate include)
build:backend:api:
  stage: build
  image: python:$PYTHON_VERSION
  before_script:
    - pip install --upgrade pip
    - pip install -r requirements.txt
  script:
    - echo "Building backend API"
    - python -m pytest --collect-only
    - python manage.py collectstatic --noinput
  artifacts:
    paths:
      - staticfiles/
  cache:
    key: "backend-api-$CI_COMMIT_REF_SLUG"
    paths:
      - .pip-cache/

build:backend:workers:
  stage: build
  image: python:$PYTHON_VERSION
  before_script:
    - pip install --upgrade pip
    - pip install -r requirements.txt
  script:
    - echo "Building backend workers"
    - python -c "import celery; print('Celery tasks validated')"
  cache:
    key: "backend-workers-$CI_COMMIT_REF_SLUG"
    paths:
      - .pip-cache/

# Test jobs (should be in separate include)
test:frontend:unit:
  stage: test
  image: node:$NODE_VERSION
  before_script:
    - npm cache clean --force
    - npm ci --cache .npm --prefer-offline
  script:
    - npm run test:frontend:unit
  coverage: '/Coverage: \d+\.\d+%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml

test:frontend:e2e:
  stage: test
  image: node:$NODE_VERSION
  services:
    - selenium/standalone-chrome:latest
  before_script:
    - npm cache clean --force
    - npm ci --cache .npm --prefer-offline
  script:
    - npm run test:frontend:e2e
  artifacts:
    paths:
      - cypress/screenshots/
      - cypress/videos/

test:backend:unit:
  stage: test
  image: python:$PYTHON_VERSION
  services:
    - postgres:13
  variables:
    POSTGRES_DB: testdb
    POSTGRES_USER: testuser
    POSTGRES_PASSWORD: testpass
  before_script:
    - pip install --upgrade pip
    - pip install -r requirements.txt
  script:
    - python -m pytest tests/ --cov=. --cov-report=xml
  coverage: '/TOTAL.*\s+(\d+%)$/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml

# Quality jobs (should be in separate include)
quality:linting:
  stage: quality
  image: node:$NODE_VERSION
  before_script:
    - npm cache clean --force
    - npm ci --cache .npm --prefer-offline
  script:
    - npm run lint:js
    - npm run lint:css
    - pylint **/*.py
  artifacts:
    reports:
      codequality: linting-results.json

quality:sonar:
  stage: quality
  image: sonarqube/sonar-scanner-cli:latest
  script:
    - sonar-scanner -Dsonar.projectKey=$CI_PROJECT_NAME
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# Deployment jobs (should be in separate include) 
deploy:staging:frontend:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying frontend to staging S3"
    - aws s3 sync dist/ s3://staging-frontend-bucket/
  environment:
    name: staging-frontend
    url: https://staging-frontend.company.com
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

deploy:staging:backend:
  stage: deploy
  image: docker:latest
  services:
    - docker:20.10.16-dind
  script:
    - echo "Deploying backend to staging ECS"
    - docker build -t backend:$CI_COMMIT_SHA .
    - aws ecs update-service --cluster staging --service backend
  environment:
    name: staging-backend
    url: https://staging-api.company.com
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

deploy:production:
  stage: deploy
  image: alpine:latest
  script:
    - echo "Deploying full application to production"
    - kubectl apply -f k8s/
  environment:
    name: production
    url: https://app.company.com
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
      when: manual