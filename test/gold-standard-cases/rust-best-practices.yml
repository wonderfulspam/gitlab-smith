# High-quality Rust CI/CD pipeline with comprehensive testing and toolchain management
# Features: Matrix testing, cargo caching, clippy/fmt, cross-compilation, security auditing

image: rust:1.75-slim

variables:
  CARGO_HOME: $CI_PROJECT_DIR/.cargo
  CARGO_TARGET_DIR: $CI_PROJECT_DIR/target
  RUSTFLAGS: "-Dwarnings"
  RUST_BACKTRACE: "1"

# Efficient Rust compilation caching
cache:
  key:
    files:
      - Cargo.toml
      - Cargo.lock
  paths:
    - .cargo/
    - target/
  policy: pull-push

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

stages:
  - prepare
  - quality
  - test
  - build
  - security
  - deploy

# Setup Rust toolchain
setup:
  stage: prepare
  before_script:
    - apt-get update -qq && apt-get install -y -qq pkg-config libssl-dev
    - rustup component add clippy rustfmt
    - cargo --version
    - rustc --version
  script:
    - cargo fetch
  cache:
    key:
      files:
        - Cargo.toml
        - Cargo.lock
    paths:
      - .cargo/
    policy: push

# Code formatting check
format:
  stage: quality
  script:
    - rustup component add rustfmt
    - cargo fmt -- --check
  dependencies:
    - setup

# Linting with Clippy
clippy:
  stage: quality
  script:
    - rustup component add clippy
    - cargo clippy --all-targets --all-features -- -D warnings
  dependencies:
    - setup

# Matrix testing across Rust versions
test:
  stage: test
  parallel:
    matrix:
      - RUST_VERSION: ["1.70", "1.75", "stable", "beta"]
  image: rust:${RUST_VERSION}-slim
  before_script:
    - apt-get update -qq && apt-get install -y -qq pkg-config libssl-dev
    - rustup component add llvm-tools-preview
    - cargo install grcov
  script:
    - export RUSTFLAGS="-Cinstrument-coverage"
    - export LLVM_PROFILE_FILE="cargo-test-%p-%m.profraw"
    - cargo test --verbose
    # Generate coverage report
    - grcov . --binary-path ./target/debug/deps/ -s . -t cobertura --branch --ignore-not-existing --ignore '../*' --ignore "/*" -o coverage.xml
  coverage: '/^\s*lines:\s*\d+\.\d+\%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
      junit: junit.xml
    paths:
      - coverage.xml
    expire_in: 30 days
  dependencies:
    - setup

# Documentation tests
test:docs:
  stage: test
  script:
    - cargo test --doc
  dependencies:
    - setup

# Benchmarking
benchmark:
  stage: test
  script:
    - cargo bench --verbose
  artifacts:
    paths:
      - target/criterion/
    expire_in: 1 week
  dependencies:
    - setup
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  allow_failure: true

# Cross-compilation builds
build:
  stage: build
  parallel:
    matrix:
      - TARGET: ["x86_64-unknown-linux-gnu", "x86_64-unknown-linux-musl", "aarch64-unknown-linux-gnu"]
  before_script:
    - apt-get update -qq && apt-get install -y -qq pkg-config libssl-dev gcc-aarch64-linux-gnu
    - rustup target add $TARGET
  script:
    - |
      if [ "$TARGET" = "aarch64-unknown-linux-gnu" ]; then
        export CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc
        export AR_aarch64_unknown_linux_gnu=aarch64-linux-gnu-ar
      fi
    - cargo build --release --target $TARGET
    - mkdir -p binaries/$TARGET
    - cp target/$TARGET/release/* binaries/$TARGET/ 2>/dev/null || true
  artifacts:
    paths:
      - binaries/
    expire_in: 1 week
  dependencies:
    - setup
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Security audit
security:audit:
  stage: security
  before_script:
    - cargo install cargo-audit
  script:
    - cargo audit --format json --output audit-report.json
  artifacts:
    reports:
      sast: audit-report.json
    when: always
    expire_in: 1 week
  dependencies:
    - setup
  allow_failure: true

# License compliance check
security:licenses:
  stage: security
  before_script:
    - cargo install cargo-license
  script:
    - cargo license --output-format json --output-file licenses.json
    # Check for GPL licenses (example - adjust based on your needs)
    - cargo license | grep -E "(GPL|AGPL)" && exit 1 || echo "No GPL licenses found"
  artifacts:
    paths:
      - licenses.json
    expire_in: 1 week
  dependencies:
    - setup
  allow_failure: true

# Dependency tree analysis
security:dependencies:
  stage: security
  before_script:
    - cargo install cargo-tree
  script:
    - cargo tree --format "{p} {l}" --prefix none > dependency-tree.txt
    - cargo tree --duplicates >> dependency-tree.txt
  artifacts:
    paths:
      - dependency-tree.txt
    expire_in: 1 week
  dependencies:
    - setup

# Release binary artifacts
release:artifacts:
  stage: deploy
  script:
    # Create release archives
    - |
      for target_dir in binaries/*/; do
        target=$(basename "$target_dir")
        cd "$target_dir"
        tar -czf "../myapp-${target}-${CI_COMMIT_TAG:-$CI_COMMIT_SHA}.tar.gz" *
        cd ../../
      done
  artifacts:
    paths:
      - binaries/*.tar.gz
    expire_in: 30 days
  dependencies:
    - build
  rules:
    - if: $CI_COMMIT_TAG

# Container build for deployment
docker:build:
  stage: deploy
  image: docker:24-dind
  services:
    - docker:24-dind
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    # Use multi-stage Dockerfile with static musl binary
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - |
      if [ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]; then
        docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
        docker push $CI_REGISTRY_IMAGE:latest
      fi
      if [ -n "$CI_COMMIT_TAG" ]; then
        docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG
        docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG
      fi
  dependencies:
    - build
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG